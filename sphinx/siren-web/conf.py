#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# Siren documentation build configuration file, created by
# sphinx-quickstart on Thu Apr  3 20:37:32 2014.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os
from datetime import datetime
sys.path.append("__SIREN_PYTHON_PATH__")
from common_details import common_variables, getExtLinks
cv = common_variables

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinxcontrib.bibtex', 'sphinx.ext.mathjax', 'sphinx.ext.extlinks']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['../_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = cv["PROJECT_NAME"]
copyright = cv["COPYRIGHT_YEAR_FROM"]+", "+cv["PROJECT_AUTHORS"] #+" ("+cv["MAINTAINER_EMAIL"]+")"

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '.'.join(cv["VERSION"].split('.')[:-1])
# The full version, including alpha/beta/rc tags.
release = cv["VERSION"]

cv["SPEC_RELEASE"] = release
extlinks = getExtLinks(cv)
print "EXTLINKS", extlinks

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
# today_fmt = '%B, %Y'
today = datetime.strptime(cv["LAST_CHANGES_DATE"].split(" +")[0], "%a, %d %b %Y %H:%M:%S").strftime("%B, %Y")

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build', 'Thumbs.db', '.DS_Store']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'pyramid'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# html_theme_options = {"rightsidebar": "false"}

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
html_title = cv["PROJECT_NAME"] +" - "+ cv["PROJECT_DESCRIPTION"]

# A shorter title for the navigation bar.  Default is the same as html_title.
# html_short_title = ""

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
html_logo = "siren_icon.png"
html_favicon = "siren_icon.ico"
html_style = "custom.css"

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['../_static']

html_copy_source = False

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
html_last_updated_fmt = '%b %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}
html_sidebars = {
    '**': ['globaltoc_web.html', # 'sidebarhelp.html', 'sourcelink.html',
           'searchbox_web_toguide.html'], #, 'sourcelink.html'],
    'index': ['globaltoc.html', 'searchbox_web_toguide.html'] #, 'sourcelink.html'],
    # 'index': ['indexsidebar.html', 'sidebarhelp.html', 'sourcelink.html',
    #           'searchbox.html'],
    }

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
html_use_index = False

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'Sirendoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

'transition' : '\n\n\\bigskip{}\\',
# Additional stuff for the LaTeX preamble.
'preamble': '\\makeatletter\n\\renewenvironment{notice}[2]{\n\\begin{itshape}}'+ \
            '{\\end{itshape}}\n' + \
            '\\makeatother\n\n',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'Siren.tex',  cv["PROJECT_NAME"] +' Documentation',
   cv["PROJECT_AUTHORS"], 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', cv["PROJECT_NAME"], u'' +cv["PROJECT_NAME"]+' Documentation',
     [cv["PROJECT_AUTHORS"]], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', cv["PROJECT_NAME"], cv["PROJECT_NAME"]+' Documentation',
   cv["PROJECT_AUTHORS"], cv["PROJECT_NAME"]+" "+cv["PROJECT_DESCRIPTION"], '.',
   cv["PROJECT_DESCRIPTION"]),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'


##############################
##############################

from pybtex.style.formatting.unsrt import Style as UnsrtStyle
from pybtex.style.labels.alpha import LabelStyle as AlphaLabelStyle
from pybtex.plugin import register_plugin

# extensions = ['sphinxcontrib.bibtex']
# exclude_patterns = ['_build']

import sys
if sys.version_info < (2, 7):
   from counter import Counter
else:
   from collections import Counter

import re
import unicodedata

# from pybtex.textutils import abbreviate
# from pybtex.style.labels import BaseLabelStyle
## /usr/lib/python3/dist-packages/pybtex/style

from pybtex.style.template import (
    join, words, together, field, optional, first_of,
    names, sentence, tag, optional_field, href
)

_nonalnum_pattern = re.compile('[^A-Za-z0-9]+')
delimiter_re = re.compile(r'([\s\-])')

def abbreviate(text, split=delimiter_re.split):
   """Abbreviate the given text.
   
   >> abbreviate('Name')
   'N'
   >> abbreviate('Some words')
   'S. w.'
   >>> abbreviate('First-Second')
   'F.-S.'
   """
   
   def abbreviate(part):
      if part.isalpha():
         return part[0] + '.'
      else:
         tmp = _strip_nonalnum(part)
         if tmp.isalpha():
            return tmp[0] + '.'
         return part
      
   return ''.join(abbreviate(part) for part in split(text))

def _strip_accents(s):
   return ''.join(
       (c for c in unicodedata.normalize('NFD', s)
        if not unicodedata.combining(c)))

def _strip_nonalnum(parts):
    """Strip all non-alphanumerical characters from a list of strings.

    >>> print _strip_nonalnum([u"Ã…A. B. Testing 12+}[.@~_", u" 3%"])
    AABTesting123
    """
    s = ''.join(parts)
    return _nonalnum_pattern.sub('', _strip_accents(s))

def _abbr(parts):
    return (abbreviate(part) for part in parts)



class ApaStyle(UnsrtStyle):
    default_label_style = 'number'
    # default_sorting_style = 'author_year_title'
    default_sorting_style = 'custa'

    def format_web_refs(self, e):
        # based on urlbst output.web.refs
        return sentence [
            optional [ self.format_url(e) ],
            # optional [ self.format_eprint(e) ],
            # optional [ self.format_pubmed(e) ],
            optional [ self.format_doi(e) ],
            # optional [ self.format_file(e) ],
            # optional [ self.format_abs(e) ],
            ]
    
    def format_url(self, e):
        # based on urlbst format.url
        return words [
            'URL:',
            href [
                field('url', raw=True),
                field('url', raw=True)
                ]
        ]
    def format_file(self, e):
        # based on urlbst format.url
        return href [
                join [ './pdfs/', field('file', raw=True)],
                'pdf',
                ]

    
# class ApaLabelStyle(BaseLabelStyle):

#     # def format_label(self, entry):
#     #     return "CUSTA"

#     def format_labels(self, sorted_entries):
#         labels = [self.format_label(entry) for entry in sorted_entries]
#         count = Counter(labels)
#         counted = Counter()
#         for label in labels:
#             if count[label] == 1:
#                 yield label
#             else:
#                 yield label + chr(ord('a') + counted[label])
#                 counted.update([label])

#     # note: this currently closely follows the alpha.bst code
#     # we should eventually refactor it

#     def format_label(self, entry):
#         # see alpha.bst calc.label
#         if entry.type == "book" or entry.type == "inbook":
#             label = self.author_editor_key_label(entry)
#         elif entry.type == "proceedings":
#             label = self.editor_key_organization_label(entry)
#         elif entry.type == "manual":
#             label = self.author_key_organization_label(entry)
#         else:
#             label = self.author_key_label(entry)
#         if "year" in entry.fields:
#             return label + entry.fields["year"][-2:]
#         else:
#            return label
#         # bst additionally sets sort.label

#     def author_key_label(self, entry):
#         # see alpha.bst author.key.label
#         if not "author" in entry.persons:
#             if not "key" in entry.fields:
#                 return entry.key[:3] # entry.key is bst cite$
#             else:
#                 # for entry.key, bst actually uses text.prefix$
#                 return entry.fields["key"][:3]
#         else:
#             return self.format_lab_names(entry.persons["author"])

#     def author_editor_key_label(self, entry):
#         # see alpha.bst author.editor.key.label
#         if not "author" in entry.persons:
#             if not "editor" in entry.persons:
#                 if not "key" in entry.fields:
#                     return entry.key[:3] # entry.key is bst cite$
#                 else:
#                     # for entry.key, bst actually uses text.prefix$
#                     return entry.fields["key"][:3]
#             else:
#                 return self.format_lab_names(entry.persons["editor"])
#         else:
#             return self.format_lab_names(entry.persons["author"])

#     def author_key_organization_label(self, entry):
#         if not "author" in entry.persons:
#             if not "key" in entry.fields:
#                 if not "organization" in entry.fields:
#                     return entry.key[:3] # entry.key is bst cite$
#                 else:
#                     result = entry.fields["organization"]
#                     if result.startswith("The "):
#                         result = result[4:]
#                     return result
#             else:
#                 return entry.fields["key"][:3]
#         else:
#             return self.format_lab_names(entry.persons["author"])

#     def editor_key_organization_label(self, entry):
#         if not "editor" in entry.persons:
#             if not "key" in entry.fields:
#                 if not "organization" in entry.fields:
#                     return entry.key[:3] # entry.key is bst cite$
#                 else:
#                     result = entry.fields["organization"]
#                     if result.startswith("The "):
#                         result = result[4:]
#                     return result
#             else:
#                 return entry.fields["key"][:3]
#         else:
#             return self.format_lab_names(entry.persons["editor"])

#     def format_lab_names(self, persons):
#         # see alpha.bst format.lab.names
#         # s = persons
#         numnames = len(persons)
#         if numnames > 1:
#             if numnames > 3:
#                person = persons[0]
#                # result = _strip_nonalnum(person.prelast_names + person.last_names)[:3]
#                result = _strip_nonalnum(person.last_names)[:3]
#                result += "+"
#             else:
#                 namesleft = numnames
#                 result = ""
#                 nameptr = 1
#                 while namesleft:
#                    person = persons[nameptr - 1]
#                    # tmpre = _strip_nonalnum(_abbr(
#                    #    person.prelast_names + person.last_names))
#                    tmpre = _strip_nonalnum(_abbr(person.last_names))
#                    if nameptr == numnames:
#                       if person == "others":
#                          result += "+"
#                       else:
#                          result += _strip_nonalnum(_abbr(person.last_names))
#                    else:
#                       result += _strip_nonalnum(_abbr(person.last_names))
#                    nameptr += 1
#                    namesleft -= 1
#         else:
#             person = persons[0]
#             result = _strip_nonalnum(_abbr(person.last_names))
#             if len(result) < 2:
#                 result = _strip_nonalnum(person.last_names)[:3]
#         return result


# inspired from Andrey Golovizin

from pybtex.style.sorting import BaseSortingStyle


class CustSortingStyle(BaseSortingStyle):

    def sorting_key(self, entry):
        if entry.type in ('book', 'inbook'):
            author_key = self.author_editor_key(entry)
        elif 'author' in entry.persons:
            author_key = self.persons_key(entry.persons['author'])
        else:
            author_key = ''
        return (entry.fields.get('year', ''), author_key, entry.fields.get('title', ''))
     
    def persons_key(self, persons):
       if len(persons) > 3:
          return self.person_key(persons[0])+"  et al"
       return '   '.join(self.person_key(person) for person in persons)

    def person_key(self, person):
       return '  '.join((
            ' '.join([_strip_nonalnum(person.prelast_names)] + [_strip_nonalnum(person.last_names)]),
            # ' '.join(person.first_names + person.middle_names),
            # ' '.join(person.lineage_names),
        )).lower()

    def author_editor_key(self, entry):
        if entry.persons.get('author'):
            return self.persons_key(entry.persons['author'])
        elif entry.persons.get('editor'):
            return self.persons_key(entry.persons['editor'])
        else:
            return ''

#register_plugin('pybtex.style.labels', 'custa', LabelStyle)
register_plugin('pybtex.style.formatting', 'custa', ApaStyle)
register_plugin('pybtex.style.sorting', 'custa', CustSortingStyle)
